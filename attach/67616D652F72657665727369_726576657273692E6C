(provide "reversi")

(in-package "editor")

(export '(reversi))

(defvar reversi-mode-map nil "reversiモードのキーマップ")

(unless reversi-mode-map
  (setq reversi-mode-map (make-sparse-keymap))
  (define-key reversi-mode-map #\C-m 'reversi-human-plays))

(defun reversi-mode ()
  "reversiモード"
  (interactive)
  (setq buffer-mode 'reversi-mode mode-name "reversi")
  (make-local-variable 'mode-line-format)
  (set-buffer-fold-width nil)
  (use-keymap reversi-mode-map))

(defvar *board*)
(defvar *board-work*)
(defvar *ct*)
(defvar *end*)
(defconstant *none* 0)
(defconstant *black* 1)
(defconstant *white* 2)

(defun result ()
  (let ((bc 0)(wc 0))
	(dotimes (i 8)
	  (dotimes (j 8)
		(cond ((= (aref *board* i j) *black*) (incf bc))
			  ((= (aref *board* i j) *white*) (incf wc)))))
	(message "勝負がつきました あなた~D わたし~D" bc wc)))

(defun pass (me)
  (let ((cnt 0))
	(dotimes (i 8)
	  (dotimes (j 8)
		(setq cnt (+ cnt (check-put i j me)))))
	(= cnt 0)))

(defun game-over ()
  (let ((cnt 0))
	(dotimes (i 8)
	  (dotimes (j 8)
		(setq cnt (+ cnt (check-put i j *black*)))))
	(dotimes (i 8)
	  (dotimes (j 8)
		(setq cnt (+ cnt (check-put i j *white*)))))
	(= cnt 0)))

(defun turn (ax ay me)
  (dotimes (i 8)
	(dotimes (j 8)
	  (if (= (aref *board-work* i j) 2)
		  (setf (aref *board* i j) me)))))

(defun dispa ()
  (dotimes (i 8)
	(dotimes (j 8)
	  (cond ((= (aref *board* j i) *none*) (princ "_"))
			((= (aref *board* j i) *black*) (princ "*"))
			((= (aref *board* j i) *white*) (princ "O"))))
	(princ "\n")))

(defun disp ()
  (dotimes (i 8)
	(dotimes (j 16) (princ "−"))
	(princ "\n")
	(dotimes (j 8)
	  (princ "｜")
	  (cond ((= (aref *board* j i) *none*) (princ "　"))
			((= (aref *board* j i) *black*) (princ "●"))
			((= (aref *board* j i) *white*) (princ "○"))))
	(princ "｜\n"))
  (dotimes (i 16) (princ "−")))

(defun check-put (ax ay me &optional (tf nil))
  (let ((x)(y)(you)(cnt 0)(wcnt)(flg))
	(if (/= (aref *board* ax ay) *none*) (return-from check-put 0))
	(if tf
		(dotimes (i 8)
		  (dotimes (j 8)
			(setf (aref *board-work* j i) *none*))))
	(cond ((= me *black*) (setq you *white*))
		  ((= me *white*) (setq you *black*))
		  (t (plain-error)))
	(dotimes (i 8)
	  (setq flg 0)
	  (setq wcnt 0)
	  (dotimes (j 8)
		(setq x (+ (* (aref *ct* i 0) (+ j 1)) ax))
		(setq y (+ (* (aref *ct* i 1) (+ j 1)) ay))
		(if (or (< x 0) (> x 7) (< y 0) (> y 7)) (return))
		(if flg
			(cond ((= (aref *board* x y) you)
				   (incf wcnt)
				   (if tf (setf (aref *board-work* x y) 1)))
				  ((= (aref *board* x y) me)
				   (setq cnt (+ cnt wcnt))
				   (if tf
					   (dotimes (k 8)
						 (dotimes (m 8)
						   (if (= (aref *board-work* k m) 1)
							   (setf (aref *board-work* k m) 2)))))
				   (return))
				  (t (return)))
		  (if (= (aref *board* x y) you)
			  (progn (incf wcnt)
				(if tf (setf (aref *board-work* x y) 1))
				(setq flg 1))
			(return))))
	  (if tf
		  (dotimes (k 8)
			(dotimes (m 8)
			  (if (/= (aref *board-work* k m) 2) (setf (aref *board-work* k m) 0))))))
	cnt))

(defun reversi-com-plays ()
  (dotimes (i 8)
	(dotimes (j 8)
	  (if (> (check-put i j *white*) 0)
		  (progn (check-put i j *white* t)
			(turn i j *white*)
			(setf (aref *board* i j) *white*)
			(return-from reversi-com-plays))))))

(defun reversi-human-plays ()
  (interactive)
  (let ((x (mod (point) 9))(y (floor(/ (point) 9)))(prepos (point)))
	  (if *end* (progn (result) (return-from reversi-human-plays)))
	  (if (or (= x 8) (= y 8)) (return-from reversi-human-plays))
	  (if (> (check-put x y *black*) 0)
		  (progn (check-put x y *black* t)
			(turn x y *black*)
			(setf (aref *board* x y) *black*)
			(if (game-over) (progn (setq *end* t)(result) (return-from reversi-human-plays)))
			(if (pass *white*) (return-from reversi-human-plays))
			(reversi-com-plays)
			(if (game-over) (progn (setq *end* t)(result) (return-from reversi-human-plays)))
			(if (pass *white*) (return-from reversi-human-plays))
			(while (pass *black*)
			  (reversi-com-plays)
			  (if (game-over) (progn (setq *end* t) (result) (return-from reversi-human-plays)))
			  (if (pass *white*) (return-from reversi-human-plays)))
			(toggle-read-only nil)
			(erase-buffer "*reversi*")
			(with-output-to-selected-buffer (dispa))
			(goto-char prepos)
			(toggle-read-only t)))))

(defun reversi ()
  (interactive)
  (setf *board* (make-array '(8 8)))
  (dotimes (i 8)
	(dotimes (j 8)
	  (setf (aref *board* j i) *none*)))
  (setf *board-work* (make-array '(8 8)))
  (dotimes (i 8)
	(dotimes (j 8)
	  (setf (aref *board-work* j i) *none*)))
  (setf *ct* (make-array '(8 2):initial-contents
						 '((0 1) (1 1) (1 0) (1 -1) (0 -1) (-1 -1) (-1 0) (-1 1))))
  (setf (aref *board* 3 3) *black*)
  (setf (aref *board* 4 4) *black*)
  (setf (aref *board* 3 4) *white*)
  (setf (aref *board* 4 3) *white*)
  (setf *end* nil)
  (setq *random-state* (make-random-state t))
  (switch-to-buffer "*reversi*")
  (toggle-read-only nil)
  (reversi-mode)
  (with-output-to-selected-buffer (dispa))
  (toggle-read-only t)
  (message "あなたの番です"))
