;; 1‚©‚ç5‚Åhold
;; spc‚Åƒ`ƒFƒ“ƒW
(provide "poker")
(in-package "editor")

(export '(poker))

(defvar poker-mode-map nil)

(unless poker-mode-map
  (setq poker-mode-map (make-sparse-keymap))

  (define-key poker-mode-map #\  'change)

  (define-key poker-mode-map #\1 'hold)
  (define-key poker-mode-map #\2 'hold)
  (define-key poker-mode-map #\3 'hold)
  (define-key poker-mode-map #\4 'hold)
  (define-key poker-mode-map #\5 'hold))

(defun poker-mode ()
  (setq buffer-mode 'poker-mode mode-name "poker")
  (make-local-variable 'mode-line-format)
  (set-buffer-fold-width nil)
  (use-keymap poker-mode-map))

(defvar *talon* (make-array 52))
(defvar *hand* (make-array 5))
(defconstant *suit* (make-array 4 :initial-contents '("S" "H" "D" "C"))) ;
(defconstant *rank* (make-array 13 :initial-contents '("A " "2 " "3 " "4 " "5 " "6 " "7 " "8 " "9 " "10" "J " "Q " "K "))) ;
(defconstant *poker-hand-name* (make-array 10 :initial-contents '("Royal Straight Flush" "Straight Flush" "Four of a Kind" "Full House" "Flush" "Straight" "Three of a Kind" "Two Pair" "One Pair" "No Pair")))
(defvar *hold* (make-array 5))
(defvar *game-over* nil)

(defun change ()
  (interactive)
  (if *game-over*
	  (progn
		(init-talon)
		(dotimes (i 5) (setf (aref *hand* i) 0) (setf (aref *hold* i) nil))
		(deal-hand)
		(toggle-read-only nil)
		(erase-buffer "*poker*")
		(with-output-to-selected-buffer
		  (disp-hand))
		(toggle-read-only t)
		(set-buffer-modified-p nil)
		(setq *game-over* nil)
		(return-from change)))
  (dotimes (i 5)
	(if (not (aref *hold* i)) (setf (aref *hand* i) -1)))
  (dotimes (i 5)
	(if (= (aref *hand* i) -1)
		(do ((j (random 52)))
			((/= (aref *talon* j) -1)
			 (setf (aref *hand* i) (aref *talon* j))
			 (setf (aref *talon* j) -1))
		  (if (= j 51)
			  (setq j 0)
			(incf j)))))
  (toggle-read-only nil)
  (erase-buffer "*poker*")
  (with-output-to-selected-buffer
	(disp-hand)
	(princ (aref *poker-hand-name* (check-hand)))
	(princ "\n"))
  (toggle-read-only t)
  (set-buffer-modified-p nil)
  (setq *game-over* t))


(defun hold ()
  (interactive)
  (if *game-over* (return-from hold))
  (let ((idx (- (char-code *last-command-char*) (char-code #\1))))
	(if (aref *hold* idx)
		(setf (aref *hold* idx) nil)
	  (setf (aref *hold* idx) t))
	(toggle-read-only nil)
	(erase-buffer "*poker*")
	(with-output-to-selected-buffer
	  (disp-hand))
	(toggle-read-only t)
	(set-buffer-modified-p nil)))

(defun check-hand ()
  (let ((suit (make-array 4 :initial-element 0))
		(rank (make-array 13 :initial-element 0))
		(pair (make-array 5 :initial-element 0))
		(straight) (flush) (royal))
	(dotimes (i 5)
	  (incf (aref suit (floor (/ (aref *hand* i) 13))))
	  (incf (aref rank (mod (aref *hand* i) 13))))
	(if (= 1 (aref rank 0) (aref rank 9) (aref rank 10) (aref rank 11) (aref rank 12))
		(setq royal t))
	(dotimes (i 9)
	  (if (= 1 (aref rank i) (aref rank (+ i 1)) (aref rank (+ i 2)) (aref rank (+ i 3)) (aref rank (+ i 4)))
		  (progn (setq straight t)(return))))
	(dotimes (i 4)
	  (if (= 4 (aref suit i))
		  (progn (setq flush t)(return))))
	(dotimes (i 13)
	  (incf (aref pair (aref rank i))))

	(cond
	 ((and royal straight flush) (return-from check-hand 0))
	 ((and straight flush) (return-from check-hand 1))
	 ((= (aref pair 4) 1) (return-from check-hand 2))
	 ((and (= (aref pair 3) 1) (= (aref pair 2) 1)) (return-from check-hand 3))
	 (flush (return-from check-hand 4))
	 (straight (return-from check-hand 5))
	 ((= (aref pair 3) 1)  (return-from check-hand 6))
	 ((= (aref pair 2) 2)  (return-from check-hand 7))
	 ((= (aref pair 2) 1)  (return-from check-hand 8))
	 (t (return-from check-hand 9)))))

(defun disp-hand ()
  (dotimes (i 5)
	(princ (aref *suit* (floor (/ (aref *hand* i) 13))))
	(princ (aref *rank* (mod (aref *hand* i) 13)))
	(princ " "))
  (princ "\n")
  (dotimes (i 5)
	(if (aref *hold* i) (princ "HLD ") (princ "    ")))
  (princ "\n")
  )

(defun deal-hand ()
  (dotimes (i 5)
	(do ((j (random 52)))
		((/= (aref *talon* j) -1)
		 (setf (aref *hand* i) (aref *talon* j))
		 (setf (aref *talon* j) -1))
	  		(if (= j 51)
			(setq j 0)
		  (incf j)))))

(defun init-talon ()
  (dotimes (i 52)
	(setf (aref *talon* i) -1))
  (dotimes (i 52)
	(do ((j (random 52)))
		((= (aref *talon* j) -1)
		 (setf (aref *talon* j) i))
	  		(if (= j 51)
			(setq j 0)
		  (incf j)))))

(defun poker ()
  (interactive)
  (setq *random-state* (make-random-state t))
  (switch-to-buffer "*poker*")
  (poker-mode)
  (init-talon)
  (deal-hand)
  (with-output-to-selected-buffer
	(disp-hand))
  (toggle-read-only t)
  (set-buffer-modified-p nil))
