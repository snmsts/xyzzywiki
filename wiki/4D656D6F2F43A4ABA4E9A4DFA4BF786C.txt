[[Memo]]
#contents
*xyzzy lispとC言語との対比 [#p19df74f]

書きかけ…K&Rはもってたはずどこ行った？適当に気が向いたときに書き足してく予定。
手を加えていって最後にゃライセンスはhttp://xyzzy.s53.xrea.com/docs/copyright.htmlにします…

なんとなくで書いています。正確かどうかでいくとあまり参考にすべき資料ではありません。

**lispの基礎、前置記法の基本。 [#g80c0081]
-括弧の一番左側が手続き名（関数やらマクロやら特殊式やら実際いろいろありますが関数と思ってください）
-二番目の要素から順順に評価されていきます。
-中で括弧にぶつかったときには同様に処理する。

例とか
 (+ 3 (* 2 4) 5)
 => 16

**xlは [#f6a30d67]
-必ずしもコンパイルするわけではない。（評価の順はファイルの頭から順にと思っていただければ。）
-main関数とかそういう縛りは無い。（手続きを関数の外に書ける。）
-関数は関数を定義する関数（実際はマクロ）を呼ぶとでける。（呼ぶと関数を定義する関数なんかも楽勝作れる）

**関数や変数の宣言 [#l3b6ad9d]
関数や変数の定義はC流儀で考えると、void*の変数に
対して（関数、変数）ポインタのアドレスを代入することで実現されていると思うと良いかもしれない。（細かい話は後で）
この場合のvoid*の変数のことをシンボルという。
シンボルの宣言をする必要は無く、代入するときに勝手に名前を付けることができる。

C言語での変数
 int val=1;
lispでの変数
 (setf val 1)

C言語での関数（しらんけど）
 int dbl(int x){return 2*x;}
lispでの関数
 (defun dbl(x) (* 2 x))
**シンボルに使える文字… [#v25267c5]
何でもシンボルに出来ます。制限はほぼ無いと思います。日本語も可能
空白を含むシンボルもエスケープを絡めると出来ます。
エスケープ処理を含めるとシンボルにならないものがあったかどうだか…
Cの範囲で関数、変数に使っていたものは
何も工夫する必要がありません。そのままシンボルになると思います。

**予約語 [#d2fe55c9]
真偽値をあらわすt,nil以外に予約語があったかどうだったか…定数が予約？よくわからん
上書きしてしまうと何も出来なくなるもしくは処理に困るシンボルが存在するにはあります。
xlに限っていえばすでに定義済みのシンボルをハイライト表示をすることが出来るので
シンボルの衝突を避けるのは難しいことではないと思います。
またCとは比べ物にならないほど強力な衝突防止機構。namespaceがあります。(C++とにてますかな)

**データ型 [#p56c8716]
色々あります。Cのような変数宣言はあまりせず、（したことないや）
宣言をしないときは代入時に型が決まるということです。
サンプルはすべてシンボルaに代入って方向で…

とりあえず覚えておいてほしい型は
-整数型
-浮動小数点
-文字型
-文字列型


くらいでしょうか。他にも調べるといろいろあります。複素数やら分数やら
***整数 [#n5e65a13]

shortとかlongとかlong longとかありません。みんなintegerです。
unsignedは多分無いんじゃないかなぁ。きっと

整数の代入はすごく直感的
 (setf a 10000000000000000000000000)
二進数もあったり
 (setf a #2r10101)
八進数もできるね
 (setf a #8r702)
二十七進数って？なにそれ？
 (setf a #27rHG)

***浮動小数点 [#o026afe3]

普通の（デフォルトではCのfloatと同じかなぁ）
 (setf a 1.0)
double?
 (setf a 1.0L0)

***文字型 [#a68f09a9]

 (setf a #\a)
***文字列型 [#t505a867]

 (setf a "hoge")

***文字列と文字の変換 [#j9843531]

文字列は文字の配列として実装されていない。

文字から文字列への変換
 (format nil "~C" #\a)

文字列から文字への変換（一文字目を変換）
 (char "hoge" 0)

**関数 [#tc795ddb]
少し考える。

**変数の記憶クラスとスコープ [#w2d1b13e]
関数の説明をしないといかんね後回し

**配列 [#y1828562]
#配列って何に使うんだっけ？
Cでのコード
 int a[2][4]={{0,1,2,3},{3,2,1,0}};
 printf("%d",a[1][1]);
 a[1][1]=100;
をlispに
 (setf a (make-array '(2 4) :initial-contents '((0 1 2 3) (3 2 1 0))))
 (format t "~d" (aref a 1 1))
 (setf (aref a 1 1) 100)
少し冗長…

**構造体 [#bef8cac3]
Cのコード
 struct point {
   int x;
   int y;
 };
 struct point p;
 p.x=0;
 p.y=3;

lispのコード
 (defstruct point x y)
 (setf p (make-point))
 (setf (point-x p) 0)
 (setf (point-x p) 3)

こんな感じかね。lispでの構造体の初期値はnil（弄りたければ弄れますよ）

**算術演算子 [#a8d48040]
**関係演算子 [#za16bda7]
**論理演算子 [#rdff68ca]
**ビット演算 [#zf0a65a0]
**制御文 [#k318c867]
if,while,for,switch,do while,
*標準ライブラリの代替コード… [#led16ca8]
別ページに…っつかしらべんとねぇ…。
-[[stdio.h]]
-[[stdlib.h]]
-[[string.h]]
----
よくわかんないけどつまりどころとかいろいろあったら教えてください。
#pcomment
